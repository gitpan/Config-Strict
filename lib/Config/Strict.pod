=head1 NAME

Config::Strict - Add strict name- and type-checking to configuration data

=head1 VERSION

0.03 (alpha release)

=head1 SYNOPSIS

    use Config::Strict;
    use Declare::Constraints::Simple -All;               # For custom checks

    # A comprehensive example
    my $config = Config::Strict->new( {
        name   => "Example",                             # Type system name
        params => {                                      # Parameter types & names
            Bool     => [ qw( my_bool1 my_bool2 ) ],     # Multiple parameters
            Int      => 'my_i',                          # Single parameter
            Num      => 'my_n',
            Str      => [ qw( my_str1 my_str2 ) ],
            Regexp   => 'my_re',
            ArrayRef => 'my_aref',
            HashRef  => 'my_href',
            CodeRef  => 'my_cref',
            Enum     => { my_enum => [ qw( v1 v2 ), undef ] },
            Custom   => {                                # Custom profiles
                my_pos2 =>                               # Positive number
                    And( IsNumber, Matches( qr/^[^-]+$/ ) ),
                my_nest => IsA( 'Config::Strict' ),      # Nested configuration
            }
        },
        required => [ qw( my_bool1 my_n ) ],             # Required parameters
        defaults => {                                    # Default values
            my_bool1    => 1,
            my_str2     => 'str',
            my_enum     => 'e2',
            my_n        => -1.1,
            my_pos2     => 1_000,
        },
    } );
    
    # Access and change the data
    
    # Retrieve a single value
    $config->get_param( 'my_n' );                       # -1.1
    
    # Retrieve a list of values
    $config->get_param( qw( my_bool1 my_str2 ) );       # ( 1, 'str' )
    
    # Set multiple parameters
    $config->set_param( my_bool1 => 1, 'my_pos2' => 2 );   
    
    # Unset parameters
    $config->unset_param( 'my_n' );
    $config->param_is_set( 'my_n' );                    # false
    
    # The following will die:
    $config->get_param( 'bad_name' );           # bad_name doesn't exist in the configuration
    $config->set_param( 'my_i' => 2.2 );        # my_i must be an integer
    $config->set_param( 'my_pos2' => -5 );      # my_pos2 must be positive
    
=head1 DESCRIPTION

Config::Strict utilizes L<Declare::Constraints::Simple> to enable strict 
parameter name- and type-checking on configuration data. Both built-in and 
custom types can be used to build a validation profile for the entire 
configuration.

A typical workflow might be:

=over 4

=item 1. Use some configuration module to parse a configuration file and load its data.

=item 2. Construct a C<Config::Strict> type system for your configuration data.

=item 3. Load the parsed configuration hash into the Config::Strict object using C<set_param>.

=item 4. Use C<get_param> in your program to access configuration values.

=item 5. Write any changes back to disk using some module.

=back

See L<Declare::Constraints::Simple::Library> for an index to available constraints and the parent documentation for defining your own constraints and scoping.

This is a L<Moose> module.

=head1 CONSTRUCTING A TYPE SYSTEM

Declare the type system during construction:

=head2 Config::Strict->new( \%config_profile )

C<%config_profile> is a multi-level hash with the following top-level keys:

=over 4

=item B<name> (Required)

Points to the name of the type system. This name is appended to 
"Config::Strict::Params::" for proper namespacing of the Moose HashRef subtype 
that uniquely describes the entire configuration data structure. See 
L<Moose::Meta::TypeConstraint> for more details.

=item B<params> (Required)

Points to the hash of parameter types and names, where the keys are the 
built-in Config::Strict types (more below). 

The values are either a single parameter name or an arrayref of parameter names,
with the exception of the special types C<Enum> and C<Custom> which point to a 
uniquely defined hashref.

Any parameter not named here cannot be added later - any attempt to L<access a
parameter|/"GETTING AND SETTING PARAMETER VALUES"> that is not provided in the 
constructor will result in an error.

B<Parameter Types And Values:>

=over 4

=item B<Bool>

Parameters taking the value 0 or 1.

=item B<Int>

Integer parameters.

=item B<Num>

Generic number parameters.

=item B<Str>

Generic string parameters.

=item B<Enum>

Enumerated parameters. The C<Enum> key points to a hashref with
C<$parameter_name =E<gt> $values> pairs, where C<$values> is an arrayref of 
valid values for the enum C<$parameter_name>.

=item B<Regexp>

Compiled regexp parameters (with C<qr//>).

=item B<ArrayRef>

Generic list parameters.

=item B<HashRef>

Generic hash parameters.

=item B<CodeRef>

Generic code parameters.

=item B<Custom>

Custom validation code. The C<Custom> key points to a hashref with C<$parameter_name =E<gt> $coderef> pairs, where C<$coderef> is a routine that validates a single argument and returns true or false (1 or 0) if the given value is a valid one for that parameter.

As of version 0.03, C<$coderef> must be a L<Declare::Constraints::Simple> "profile." These code profiles will in fact return a L<Declare::Constraints::Simple::Result> which evaluate properly in boolean context and give more information (see their documentation for details).

Future versions may have the option of literal routines (C<sub { my $val = $_[0]; ... }>) which will be wrapped automatically in a profile.

=back

=item B<required> (Optional)

Points to a arrayref of parameter names that must have valid values at all times.
These parameters must also be given a default value.

The special value '_all' in the first location is a shortcut to specify that all 
parameters are to be required.

=item B<defaults> (Optional)

Points to a hashref of default values to any number of parameters. 
Those parameters listed in C<required> I<must> be present in this section.

=back

=head1 METHODS

=head2 GETTING AND SETTING PARAMETER VALUES

These methods will die with a stack trace if a given parameter doesn't exist in the configuration profile, or if an attempt is made to set a parameter with an invalid value.

=over 4

=item $obj->get_param( $param1, $param2, ... )

Returns the list of values corresponding to each parameter.

=item $obj->set_param( $param1 => $value1, $param2 => $value2, ... )

Sets each parameter-value configuration pair.

=item $obj->unset_param( $param1, $param2, ... )

Unsets each parameter; internally deletes the parameter-value pair from the underlying parameter hash.

Required parameters cannot be unset.

=back

=head2 PARAMETER CHECKING

The following methods can be used to check conditions on parameters without killing the program.

=over 4

=item $obj->validate( $param1 => $value1, $param2 => $value2, ... )

Returns true if all parameter-value pairs are valid; false otherwise.

=item $obj->param_exists( $param )

Returns true if C<$param> can be get/set; false otherwise.

=item $obj->param_is_set( $param )

Returns true if C<$param> has been set; false otherwise.

=item $obj->param_is_required( $param )

Returns true if C<$param> is a required parameter; false otherwise.

=back

=head2 OTHER METHODS

=over 4

=item $obj->all_params()

Returns the list of all parameters in the configuration.

=item $obj->all_set_params()

Returns the list of all set parameters in the configuration.

=item $obj->param_hash()

Returns a copy of the underlying configuration data as a list of key-value pairs.

=item $obj->param_array()

Returns a copy of the underlying configuration data as an array of array references.

=item $obj->get_profile( $param )

Returns the L<Declare::Constraints::Simple> "profile" used to validate C<$param>; it takes a single argument and returns true if the passed argument would be a valid value for C<$param>. If it's a  profile (true for all cases except custom bare coderefs) it will more specifically return a L<Declare::Constraints::Simple::Result>.

=back

=head1 EXTENDING THE DEFAULT TYPES

There are several ways to make your type system even more strict than the
provided parameter types:

=over 4

=item 1. Using the C<Custom> key and combining any number of 
C<Declare::Constraints::Simple> routines, and/or your own.

=item 2. Using the C<Custom> key and defining your own validation coderefs. (B<TODO>)

=item 3. Subclassing Config::Strict and augmenting the C<_get_check>, C<_set_check>, and C<_unset_check> validation methods to add your own general validation semantics. These methods are executed before C<get_param>, C<set_param>, and C<unset_param>, respectively, and receive the same arguments in C<@_>. 

See also L<Moose::Manual::MethodModifiers/"INNER_AND_AUGMENT">.

=back

B<TODO>:
    - Document more code examples
    - Custom type class registration
    - DCS profile wrapper mechanism

=head1 SEE ALSO

L<Declare::Constraints::Simple>

=head1 CAVEATS

This is an alpha release - the API is subject to change.


=head1 AUTHOR

Blake Willmarth

bwillmarth at gmail.com

=head1 BUGS

Please report any bugs or feature requests to C<bug-config-strict at rt.cpan.org>, or through
the web interface at L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Config-Strict>.  I will be notified, and then you'll automatically be notified of progress on your bug as changes are made.

=head1 LICENSE AND COPYRIGHT

Copyright 2010 Blake Willmarth.

This program is free software; you can redistribute it and/or
modify it under the terms of either:

=over 4

=item * the GNU General Public License as published by the Free
Software Foundation; either version 1, or (at your option) any
later version, or

=item * the Artistic License version 2.0.

=back

=cut
